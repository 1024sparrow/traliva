<!-- codepage utf-8 -->

<span style="color:#400;font-weight:8;">Текущая версия спецификации:</span>
<span style="color:#048;">1</span>

<h2>
Оглавление
</h2>
<ul>
<li><a href="#Что это за зверь">Что это за зверь</a></li>
<li><a href="#Технологический процесс">Технологический процесс</a></li>
<li><a href="#Оговорки">Оговорки</a></li>
<li><a href="#Как использовать">Как использовать</a></li>
<li><a href="#Формат объекта, передаваемого в функцию Traliva.init()">Формат объекта, передаваемого в функцию Traliva.init()</a></li>
    <ul>
    <li><a href="#Формат лэйаута">Формат лэйаута</a></li>
    <li><a href="#Формат объекта 'states'">Формат объекта 'states'</a></li>
    <li><a href="#Формат описания подсостояний">Формат описания подсостояний</a></li>
    <!--<li><a href="#Подгрузка частей веб-приложения">Подгрузка частей веб-приложения</a></li>-->
    <li><a href="#Сокращённая форма">Сокращённая форма</a></li>
    </ul>
<li><a href="#Низкоуровневые вещи">Низкоуровневые вещи</a></li>
    <ul>
    <li><a href="#Работа с состоянием и регистрацией/обработкой его изменений">Работа с состоянием и регистрацией/обработкой его изменений</a></li>
    <li><a href="#Пользовательские виджеты">Пользовательские виджеты</a></li>
    <li><a href="#API работы с лэйаутами">API работы с лэйаутами</a></li>
        <ul>
        <li><a href="#Класс Traliva.Strip">Класс Traliva.Strip</a></li>
        <li><a href="#Класс Traliva.Stack">Класс Traliva.Stack</a></li>
        </ul>
    <li><a href="#Утилиты">Утилиты</a></li>
        <ul>
        <li><a href="#Traliva.createElement()">Traliva.createElement()</a></li>
        <li><a href="#Traliva.ajax()">Traliva.ajax()</a></li>
        </ul>
    </ul>
<li><a href="#Отладка">Отладка</a></li>
<li><a href="#Лицензия">Лицензия</a></li>
</ul>

<a id="Что это за зверь"><h2> Что это за зверь </h2></a>

<p>Фрэймворк Тралива предназначен для написания единым кодом сайтов и приложений, как мобильных, так и десктопных.</p>
<p>Вы пишете веб-приложение как SPA (одностраничник), в приложении отображаете WebView с этим веб-приложением, которое общается по API с низкоуровневым кодом на целевой платформе.</p>
<p>Поддерживает адаптивность интерфейсов - для разных конфигураций экран-платформа могут использоваться разные представления (автоматически переключается при ресайзе или повороте экрана).</p>
<!--<p>Поддерживает динамическую подгрузку - отдельные части кода подгружаются и исполняются лишь при обращении к соответвующим компонентам.</p>-->
<p>Самая вкусная часть, по мнению разработчика - организация взаимодействия компонентов по шаблону "Издатель-подписчик" изменений в едином объекте, описывающем состояние веб-приложения (наподобие <a href="https://en.wikipedia.org/wiki/Redux_(JavaScript_library)">Redux</a>, только проще и с меньшим количеством ограничений). Такая организация кода позволяет производить декомпозицию действительно сложной логики.</p>

<a id = "Технологический процесс"><h2>Технологический процесс</h2></a>
<p>Технологический процесс разработки сайта, мобильного(десктопного) приложения следующий:</p>
<img src="techno_process.png"></img>

<a id="Оговорки"><h2>Оговорки</h2></a>
<p>В следующей версии данной спецификации ожидаются следующие доработки:</p>
<ul>
<li>Всплывающие подсказки и выпадающие меню (это те виджеты, которые привязаны к позиции и размерам других виджетов) - пока нет решения для их реализации... Сейчас их реализация возможна только с использованием сторонних библиотек (<a href="https://popper.js.org/">popper.js</a>). Popper:<br/>
<figure>
&lt;script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous">&lt;/script><br/>
&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.3/umd/popper.min.js" integrity="sha384-vFJXuSJphROIrBnz7yo7oB41mKfc8JzQZiCq4NCceLEaO4IHwicKwpJf9c9IpFgh" crossorigin="anonymous">&lt;/script>
</figure>
Код взят <a href="https://getbootstrap.com/docs/4.0/getting-started/download/#bootstrap-cdn">отсюда</a>.
</li>
<li>Подгрузка частей веб-приложения - подгружаться будет и GUI, и логика. Это актуально для страниц авторизации, чтобы (1) те страницы каждый раз в браузер не загружать и (2) при изменении механизма авторизации и связанных с ней страниц не менять код приложения вцелом. Авторизация - это пример, когда подгрузка частей веб-приложения нужна. Другим примером могут быть вкладки, за которыми ...(всё может быть).
</li>
</ul>
<!--<p>В данном разделе приведены общие соображения по поводу того, куда ТРАЛИВА будет двигаться дальше, чего в спецификации фреймворка пока нет, и что хотелось бы добавить в следующей версии спецификации...</p>
<ul>
<li>Сейчас фреймворк ТРАЛИВА не включает в себя средств минимизации кода.</li>
<li>Логика строится посредством набора обработчиков единого объекта состояния, но нет механизма отладки и отслеживания последовательности изменений состояния (сейчас отображение отладочных виджетов требует дополнительных телодвижений со стороны разработчика).</li>
<li>Необходимо сделать проверку на соответвие кода спецификации на этапе сборки.</li>
<li>Писать логику для кроссплатформенного решения на JavaScript - это странно... Возможно, будет предложено логическую часть писать на C/C++ или <a href="https://ru.wikipedia.org/wiki/Rust_(%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)">Rust</a>, которая для веба будет компилироваться в байт-код(см. <a href="https://ru.wikipedia.org/wiki/WebAssembly">WebAssembly</a>, <a href="http://asmjs.org/">asm.js</a>) </li>
</ul>-->

<a id="Как использовать"><h2>Как использовать</h2></a>

<figure>
&lt;html><br/>
&lt;head><br/>
&lt;meta name="viewport" content="width=device-width; user-scalable=0;" /><br/>
&lt;script src="traliva.js">&lt;/script><br/>
...<br/>
&lt;/head><br/>
...<br/>
&lt;body><br/>
...<br/>
&lt;noscript> Для работы сайта необходимо, чтобы поддержка JavaScript не была отключена.&lt;/noscript><br/>
&lt;script src="gameplay.js">&lt;/script><br/>
&lt;/body><br/>
&lt;/html>
</figure>

<p>Внутри gameplay.js делаем вызов</p>
<figure>
Traliva.init(o);
</figure>
<p>Функция <ww>Traliva.init()</ww> не предполагает множественного вызова. При повторном вызове этого метода в консоль должно быть выведено сообщение об ошибке.</p>

<a id="Формат объекта, передаваемого в функцию Traliva.init()"><h2> Формат объекта, передаваемого в функцию Traliva.init()</h2></a>

<p>Передаваемый в функцию Traliva.init() объект должен иметь следующие поля:</p>
<ul><li><ww>target</ww><br/>
идентификатор платформы. Например, для сайта здесь может быть 'web', а для мобильного приложения под Android - 'android'. Эта строка зашивается жёстко в код на этапе компиляции(написания) скрипта gameplay.js. Зачем этот идентификатор платформы оставлять в коде - для возможности быстрого переключения между разными версиями веб-приложения на этапе разработки.</li>
<li><ww>get_layout</ww></li>
<li><ww>layouts</ww></li>
<li><ww>widgets</ww></li>
<li><ww>states</ww></li>
<li><ww>extender</ww></li>
<li><ww>initApi</ww></li></ul>

<p>
В зависимости от размеров экрана или от платформы (предполагается, что помимо сайтов, фреймворк также используется для создания графических интерфейсов программ) элементы страницы располагаются тем или иным образом. Взаимное расположение элементов задаёт объект, который мы называем лэйаутом. Для разных платформ и разных размеров экрана (окна) могут применяться разные лэйауты. Объект, передаваемый параметром в <ww>Traliva.init()</ww> должен содержать свойства <ww>target</ww>(строковый идентификатор платформы - например, для сайта это может быть 'web', а для приложения под Android - 'android'), <ww>get_layout</ww>(функция, параметры - ширина w, высота h, идентификатор платформы target; возвращает идентификатор лэйаута) и <ww>layouts</ww> (объект, используемый как Map, в котором строковому идентификатору лэйаута ставится в соответствие лэйаут). Формат описания лэйаута приведён ниже (см. 'Формат лэйаута'). При изменении размеров области отображения (ресайз окна на десктопе или поворот экрана на мобиле), лэйауты должны сменять друг друга согласно <ww>get_layout</ww>.
</p>
<figure>
Traliva.init({<br/>
<tab></tab>...<br/>
<tab></tab>target: 'web',<br/>
<tab></tab>get_layout: function(w,h,target){<br/>
<tab></tab><tab></tab>...<br/>
<tab></tab><tab></tab>return 'id лэйаута';<br/>
<tab></tab>},<br/>
<tab></tab>layouts: {<br/>
<tab></tab><tab></tab>'id лэйаута': {<br/>
<tab></tab><tab></tab><tab></tab>... лэйаут<br/>
<tab></tab><tab></tab>}<br/>
<tab></tab>},<br/>
<tab></tab>...<br/>
});
</figure>
В описании лэйаута могут упоминаться пользовательские виджеты (наследуются от класса <ww>Traliva.WidgetStateSubscriber</ww>) - в лэйауте указывается их строковый идентификатор (вы сами его задаёте), по которому функция <ww>Traliva.init()</ww> будет искать в свойстве <ww>widgets</ww> передаваемого параметром объекта. Свойство <ww>widgets</ww> представляет собой объект, в котором идентификаторам виджетов ставится в соответствие объект, описывающий виджет. Объект, опиывающий виджет, имеет следующие свойства:
<ul>
<li>constructor <span style="color:#666;">- конструктор виджета</span></li>
<li>options <span style="color:#666;">- необяз; объект параметров, который будет передан конструктору виджета (например, заголовок, цвета, режим здесь могут быть указаны)</span></li>
<li>substate <span style="color:#666;">- необяз; подсостояние</span></li>
</ul>
Если опций нет и подсостояние не используется, может использоваться сокращённая форма: вместо объекта, описывающего виджет, использовать конструктор виджета.

<figure>
Traliva.init({<br/>
<tab></tab>...<br/>
<tab></tab>widgets: {<br/>
<tab></tab><tab></tab>'id виджета': {<br/><!--[MyWidget, 'mySubstate/helloText'],<br/>-->
<tab></tab><tab></tab><tab></tab>constructor: MyWidget,<br/>
<tab></tab><tab></tab><tab></tab>options: {id:'catalogue', title:'Каталог', valueVarName:'mode'},<br/>
<tab></tab><tab></tab><tab></tab>substate: 'mySubstate/modeObject'<br/>
<tab></tab><tab></tab>},<br/>
<tab></tab><tab></tab>'id другого виджета': MyWidget2<br/>
<tab></tab>},<br/>
<tab></tab>...<br/>
});
</figure>
<p>Для всего нашего веб-приложения определяется единый объект состояния (обычный JavaScript-объект). Все пользовательские виджеты наследуются от класса <ww>Traliva.WidgetStateSubscriber</ww>, и являются подписчиками изменений этого единого виджета состояния. Всевозможные компоненты загрузки, воспроизведения и т.д. осуществляются с помощью подписчиков на изменения состояния (отнаследуйтесь от класса <ww>Traliva.LogicsStateSubscriber</ww>), компоненты взаимодействуют друг с другом посредством единого объекта состояния.
Итак, нам для задания программы нужны</p>
<ol>
<li>Исходное состояние веб-приложения</li>
<li>Совокупность обработчиков-инициаторов изменений состояния</li>
<p>И, на самом деле, нам нужна ещё связь состояния веб-приложения с URL просматриваемой страницы. Если пользователь зашёл по сложному URL, мы должны соответствующим образом предоставить исходное состояние веб-приложения. И наоборот - если пользователь перешёл куда-то, что-то включил, он изменил состояние веб-приложения, которое должно отображаться по соответствующему URL, чтобы, когда пользователь сохранит ссылку на этот URL и позднее перейдёт по нему, он увидел то место, куда когда-то переходил, и нашёл то, что тогда включил, включенным. Так что добавляем третий пункт...</p>

<li>Связь состояния веб-приложения и URL</li>
</ol>

<p>Всё это определяется в свойстве <ww>states</ww> объекта, передаваемого параметром в функцию <ww>Traliva.init()</ww> - см. 'Формат объекта states' ниже.</p>
<figure>
Traliva.init({<br/>
<tab></tab>...<br/>
<tab></tab>states: {<br/>
<tab></tab><tab></tab>...<br/>
<tab></tab>},<br/>
<tab></tab>...<br/>
});
</figure>

<p>Ну вот, осталось последнее свойство объекта, передаваемого параметром в функцию <ww>Traliva.init()</ww> - необязательное свойство <ww>initApi</ww>.</p>
<p>Если мы хотим, чтобы код нашего веб-приложения кроме того что работал в браузере пользователя, ещё и выступал как GUI для приложения под Android (или любую другую платформу), мы должны предоставить возможность веб-приложению "общаться" с неким API, который может представлять функционал, реализованный за пределами web-движка (нативный код). В случае запуска из браузера, API взаимодействия с "нативным кодом" будет представлен набором функций, написанных на JavaScript (возможно, заглушки). "Окно во внешний мир" - <ww>Traliva.api</ww> - подключать JavaScript-интерфейс взаимодействия с нативным кодом нужно сюда. Так вот, свойство <ww>initApi</ww> объекта, передаваеймого перематром в функцию <ww>Traliva.init()</ww> - это функция, принимающая параметром значение, указанное в свойстве <ww>target</ww>, и создающая все необходимые функции в объекте <ww>Traliva.api</ww>.</p>
<figure>
Traliva.init({<br/>
<tab></tab>...<br/>
<tab></tab>initApi: function(p_target){<br/>
<tab></tab>}<br/>
});
</figure>

<a id="Формат лэйаута"><h3>Формат лэйаута</h3></a>

<p>Лэйаут представляет собой описание компоновки пользовательских виджетов (которые описываются отдельно в свойстве <ww>widgets</ww> объекта, передаваемого параметром в функцию <ww>Traliva.init()</ww>).</p>
<p>При компоновке используются контейнеры виджетов. Фреймворк Тралива содержит контейнеры виджетов двух типов:</p>
<ul>
<li><ww>strip</ww> - линейный контенер - либо элементы в столбец, либо в строку</li>
<li><ww>stack</ww> - многослойный контейнер - все элементы располагаются один поверх другого. Применим для тех областей, где одни виджеты должны сменить другие.</li>
</ul>
<p>Лэйаут - это JavaScript-объект, в который вложены другие объекты, в которые, в свою очередь, могут быть вложены свои объекты... Лэйаут обязательно должен иметь тип (свойство <ww>type</ww>): <ww>'strip'</ww>, <ww>'stack'</ww>, <ww>'widget'</ww> или <ww>'const_widget'</ww>.</p>
<p>Помимо свойства <ww>type</ww> также можно задать свойство <ww>id</ww>(строка), которое задаёт идентификатор соответвующего виджета (любой лэйаут описывает какой-то виджет), к которому из кода впоследствии можно будет получить доступ последством объекта <ww>Traliva.widgets.заданный_идентификатор</ww>.</p>
<p>Вы можете указать свойство <ww>bg</ww>(строка). Это цвет фона. Если не указать, то у виджета не будет фона (т.е. фон будет прозрачным). Указывается в том виде, как это делается в CSS (например, <ww>'#ffa'</ww> или <ww>'rgba(0,0,0,0.2)'</ww>). Если указать в качестве цвета фона пустую строку, то фон будет взят у ближайшего родительского элемента, у которого он задан (если такой не будет найден, фон останется прозрачным)</p>
<subdiv>
<p>Элемент типа <ww>strip</ww> (линейный контейнер) должен иметь следующие свойства (помимо <ww>'type'</ww>):</p>
<ul>
<li><ww>orient</ww> - ориентация: может иметь значение <ww>'v'</ww>(дочерние элементы в столбец) или <ww>'h'</ww>(дочерние элементы в строку)</li>
<li><ww>items - массив объектов-обёрток над дочерними элементами.</ww></li>
</ul>
<p>Объект-обёртка дочернего элемента для линейного контейнера может имеьт два свойства:</p>
<ul>
<li><ww>size</ww>(необязательное свойство) - размер (тип строка). Поддерживаемые единицы измерения - <ww>'px'</ww>(пиксели) и <ww>'part'</ww>(часть от оставшегося после элементов с размерами в пикселях места). Например, '32px', '2 part'(с пробелом), '2part'. Если в контейнере подряд идут элементы с размерами '2part','32px' и '1part', то второй элемент будет иметь размер 32 пикселя, а первый и третий элементы поделят между собой оставшееся место в соотношении 2 к 1 соответственно. Значение по умолчанию - '1 part'.</li>
<li><ww>widget</ww>(необязательное свойство) - дочерний элемент</li>
</ul>
<p>Объект <ww>{}</ww>, переданный в качестве объекта-обёртки дочернего элемента, означает "пружинку".</p>
</subdiv>
<subdiv>
<p>Элемент типа <ww>stack</ww> (многослойный контейнер) должен иметь следующие свойства (помимо <ww>'type'</ww>):</p>
<ul>
<li><ww>items - массив дочерних элементов</ww></li>
</ul>
</subdiv>
<subdiv>
<p>Элемент типа <ww>widget</ww> - пользовательский виджет (который наследуется от <ww>Traliva.WidgetStateSubscriber</ww> и указывается в свойстве <ww>widgets</ww> объекта, передаваемого параметром функции <ww>Traliva.init()</ww>) - задаётся не объектом, а строкой - идентификатором виджета, по которому функция <ww>Traliva.init()</ww> будет искать в свойстве объекта, передаваемого параметром, <ww>widgets</ww>. Если же в поле <ww>widgets</ww> не найден соответвующий конструктор, будет создана заглушка - виджет, на котором отображается id_виджета и цвет фона имеет уникальное в рамках всего веб-приложения значения.</p>
</subdiv>
<subdiv>
<p>Элемент типа <ww>const_widget</ww> полностью аналогичен элементу типа <ww>widget</ww> с тем лишь исключением, что при динамической подгрузке контента (планируется добавить такую функциональность в следующей версии спецификации), при попытке подменить класс, представляюший данный виджет, в консоль будет выведено сообщение об ошибке и виджет не будет заменён.</p>
</subdiv>
<p>В случае, если контейнеры вам не нужны, и вы хотите видеть пользовательский виджет на всё окно, укажите идентификатор пользовательского виджета (тип строка) в качестве лэйаута.</p>
<p>Пример лэйаута:</p>
<figure>
Traliva.init({<br/>
<tab></tab>...<br/>
<tab></tab>layouts:{<br/>
<tab></tab><tab></tab>small:{<br/>
<tab></tab><tab></tab>},<br/>
<tab></tab><tab></tab>normal:{ // <-- вот он, лэйаут<br/>
<tab></tab><tab></tab><tab></tab>type: 'strip',<br/>
<tab></tab><tab></tab><tab></tab>orient: 'v',<br/>
<tab></tab><tab></tab><tab></tab>items:[<br/>
<tab></tab><tab></tab><tab></tab><tab></tab>{<br/>
<tab></tab><tab></tab><tab></tab><tab></tab><tab></tab>widget:{<br/>
<tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab>type: 'strip',<br/>
<tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab>orient: 'h',<br/>
<tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab>items:[<br/>
<tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab>{<br/>
<tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab>widget: 'header__bnCatalogue',<br/>
<tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab>size: '128px'<br/>
<tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab>},<br/>
<tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab>{<br/>
<tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab>widget: 'header__bnSaved',<br/>
<tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab>size: '128px'<br/>
<tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab>},<br/>
<tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab>{}, // stretch<br/>
<tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab>{<br/>
<tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab>widget: 'header_right__bnAuth',<br/>
<tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab>size: '64px'<br/>
<tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab>}<br/>
<tab></tab><tab></tab><tab></tab><tab></tab><tab></tab><tab></tab>]<br/>
<tab></tab><tab></tab><tab></tab><tab></tab><tab></tab>},<br/>
<tab></tab><tab></tab><tab></tab><tab></tab><tab></tab>size: '64px'<br/>
<tab></tab><tab></tab><tab></tab><tab></tab>},<br/>
<tab></tab><tab></tab><tab></tab><tab></tab>{//здесь контент будет меняться в зависимости от выбранной вкладки, занимать всё доступное место<br/>
<tab></tab><tab></tab><tab></tab><tab></tab><tab></tab>widget:'main_scene'<br/>
<tab></tab><tab></tab><tab></tab><tab></tab>},<br/>
<tab></tab><tab></tab><tab></tab><tab></tab>{<br/>
<tab></tab><tab></tab><tab></tab><tab></tab><tab></tab>// footer<br/>
<tab></tab><tab></tab><tab></tab><tab></tab><tab></tab>widget: 'footer_stub',<br/>
<tab></tab><tab></tab><tab></tab><tab></tab><tab></tab>size: '64px'<br/>
<tab></tab><tab></tab><tab></tab><tab></tab>}<br/>
<tab></tab><tab></tab><tab></tab>]<br/>
<tab></tab><tab></tab>},<br/>
<tab></tab><tab></tab>large:{<br/>
<tab></tab><tab></tab>}<br/>
<tab></tab>},<br/>
<tab></tab>...<br/>
});
</figure>

<a id="Формат объекта 'states'"><h3>Формат объекта 'states'</h3></a>

<!-- Пример: https://traliva.ru/static/tab_apps/django/1.js -->
<p>Свойство <ww>states</ww> объекта, передаваемого функции <ww>Traliva.init()</ww>, описывает связь состояния веб-приложения и его сетевого адреса URL, задаёт исходное состояние веб-приложения (исходя из его URL), а также именно в нём указываются те обработчики-инициаторы изменений состояния, которые, собственно, определяют всю логику работы веб-приложения (наследуются от класса <ww>Traliva.LogicsStateSubscriber</ww>). Перечислим свойства объекта <ww>states</ww>:</p>
<ul>
<li><ww>initState</ww></li>
<li><ww>tree</ww></li>
<li><ww>initPath</ww></li>
<li><ww>stringifyState</ww></li>
<li><ww>_prev_values</ww></li>
<li><ww>stateSubscribers</ww></li>
</ul>

<p>
<ww>initState</ww> - объект, определяющий состояние веб-приложения в том случае, если пользователь зашёл на корневую страницу.<br/>
Если пользователь зашёл на некорневую страничку, состояние будет достраиваться исходя из этого исходного состояния
</p>
<subdiv>
<p> <ww>tree</ww> - дерево переходов между сетевыми адресами. URL имеет строго древовидную структуру, и в каждый момент времени пользователь находится на том или ином узле этого дерева.
В объекте, описывающем дерево переходов, мы создаём свойства с такими именами, какие у корневой страницы могут быть поддиректории (в представлении URL).
Например, если мы пишем сайт <ww>traliva.ru</ww>, мы прописываем у <ww>tree</ww> свойства <ww>download</ww> и <ww>documentation</ww>, и теперь у нас в дереве определены URL-ы <ww>traliva.ru/download/</ww> и <ww>traliva.ru/documentation/</ww>.
Также в объекте <ww>tree</ww> прописываем свойство <ww>_default</ww>(объект), пишем туда свойством <ww>processor</ww> функцию, которая будет инициализировать объект состояния веб-приложения при переходе на <ww>traliva.ru/</ww> (но не на <ww>traliva.ru/download/</ww>)
По очевидной, думаю, причине не следует использовать символ <ww>/</ww>  в именовании свойств объекта <ww>tree</ww>.
В созданных нами свойствах мы можем прописать следующие свойства: </p>
<ul>
<li><ww>children</ww></li>
<li><ww>in</ww></li>
<li><ww>out</ww></li>
<li><ww>params</ww></li>
<li><ww>change</ww></li>
</ul>

<p>Свойство <ww>children</ww> - дочерние элементы этого уза дерева URL-адресов. Например, если у нас по адресу <ww>traliva.ru/download/</ww> доступны три файла на скачивание, то у нас элемент <ww>download</ww> должен иметь три дочерних элемента: <ww>1.exe</ww>, <ww>2.exe</ww> и <ww>3.exe</ww>. Свойство <ww>children</ww> имеет тип объект - названия свойств этого объекта соответствуют дочерним элементам URL. У свойства <ww>children</ww> есть также специальное свойство - <ww>_default</ww> - этот объект описывает тот случай, когда детей нет. Как и для объекта <ww>tree</ww>, это свойство имеет свойство <ww>processor</ww> - функцию, которая вызывается при переходе на такой URL.
<p>Свойства <ww>in</ww> и <ww>out</ww> - функции, которые вызываются, когда URL входит и выходит в описываемую группу URL соответственно. Параметром принимают ссылку на объект состояния, и могут добавить/удалить свойства этого объекта. Например, когда пользователь переходит с URL <ww>traliva.ru/download/</ww> на URL <ww>traliva.ru/documentation/</ww>, в узле <ww>tree &#8594; download</ww> вызывается функция <ww>out</ww>, а затем в узле <ww>tree &#8594; documentation</ww> вызывется функция <ww>in</ww>. Насчёт <ww>_default</ww> и <ww>in</ww> - сначала вызывается <ww>in</ww> и лишь потом <ww>children._default.processor</ww>, если дочерних элементов нет. При более сложных URL - сначала с конца URL до наибольшей общей части с новым URL вызываются соответвующие функции <ww>out</ww>, затем от наибольшей общей части до конца нового URL вызываются соответствующие функции <ww>in</ww>, потом вызывается функция <ww>children._default.processor</ww> конечного элемента дерева (т.е. листа дерева, а не узла).</p>
<p>Если запрашиваемый URL не соответвует дереву переходов <ww>tree</ww>, состояние сбрасывается в дефолтное (которое определено в свойстве <ww>initState</ww>)</p>
<p>Свойство <ww>params</ww> - целое число, задаёт число параметров. Если число параметров отлично от нуля, то такое количество последующих поддиректорий URL трактуются как параметры. Эти параметры при (переходе на) или при (смене параметров) используются в качестве свойств объекта параметров, передаваемого в функцию <ww>change</ww>. Функция <ww>change</ww> вызывается при изменении/применении параметров, принимает три параметра: ссылку на объект состояния веб-приложения, предыдущий набор параметров, новый набор парамеров.</p>

</subdiv>

<!--<p>Свойство <ww>initPath</ww> (тип строка) задаёт ту часть URL, начиная с имени домена, которую при анализе надо игнорировать, должно начинаться и оканчиваться на <ww>/</ww>. В большинстве случаев требуется значение <ww>/</ww> (от корня). Другие значения будут использоваться, если предполагается использование вашего сайта в <ww>&lt;iframe></ww> другого сайта. А ещё другие значения будут использоваться, когда будет динамическая подгрузка частей веб-приложения (см. 'Подгрузка частей веб-приложения' ниже).</p>-->
<p>Свойство <ww>initPath</ww> всегда должно быть равно '<ww>/</ww>' Другие значения могут быть тогда, когда будет реализован механизм динамической подгрузки контента, который планируется добавить в следующей версии спецификации.</p>
<p>Свойство <ww>stringifyState</ww> - функция, которая возвращает URL для текущего объекта состояния. Вот тут вам и пригодится свойство <ww>initPath</ww>, описанное ранее. Принимает два параметра: ссылку на объект состояния веб-приложения и ссылку на объект, свойство <ww>b</ww> которого содержит в себе флаг (тип boolean), значение <ww>true</ww> которого означает, что новый URL не будет добавлен в историю браузера, а заменит текущий.</p>
<p>Свойство <ww>_prev_values</ww> функцией <ww>Traliva.init()</ww> никак не используется - это свойство предлагается использовать разработчику для хранения предыдущих значений, для хранения данных между вызовами метода <ww>stringifyState</ww></p>
<p>Ну вот мы и подобрались к тому, что, собственно, и определяет поведение веб-приложения - набору подписчиков/инициаторов изменения состояния - свойству <ww>stateSubscribers</ww>. Это список конструкторов классов-наследников <ww>Traliva.LogicsStateSubscriber</ww> (подписчиков). Если нужно, чтобы класс подписчика выдел не всё состояние, а только какое-то его подсостояние, то вместо конструктора необходимо передать массив (<ww>[...]</ww>), состоящий из конструктора(первый элемент) и объекта, характеризующего подсостояние(второй элемент) - см. 'Формат описания подсостояний' ниже.</p>

<a id="Формат описания подсостояний"><h3>Формат описания подсостояний</h3></a>
<p>Подсостояние - это часть объекта состояния.</p>
<p>Подсостояния используются, прежде всего, при подключении сторонних пользовательских виджетов или <ww>Traliva.LogicsStateSubscriber</ww>-ов (логическая часть) - всю необходимую структуру вы создаёте в объекте состояния под каким-то одним свойством, и подключаемый объет работает в рамках того свойства, и ничего не "видит" за его пределами - он "думает", что тот объект - это и есть объект состояния веб-приложения.</p>
<p>Если подсостояние используется для модификации, то подсостояние может быть представлено только объектом или массивом (строка или целое_число не могут использовыаться в качестве подсостояния - это связано с тем, что подсостояние должно передаваться по ссылке, а не по значению). Если необходимо задать подсостояние только для чтения, то ограничений по типу нет.</p>
<p>Для указания подсостояния есть два варианта формата на ваш выбор:</p>
<ul>
<li>строка. Напишите путь к подсостоянию от корня, использую символ <ww>/</ww> в качестве разделителя. Это наиболее простая форма, но, к сожалению, не всегда возможно такое задание (например, если у вас в объекте состояния принимают участие массивы...).</li>
<li>функция. Напишите функцию, которая принимает один параметр - объект состояния, и возвращает нужное подсостояние</li>
</ul>

<a id="Сокращённая форма"><h3>Сокращённая форма</h3></a>
<p>В случае простеньких веб-приложений, которые делаются "по-быстрому на коленке", или для которых ещё не продуман дизайн для разных размеров экрана и платформ, имеет смысл упростить структуру объекта, передаваесого в функцию <ww>Traliva.init()</ww>. Приведём минимальный пример веб-приложения.</p>
<figure>
function MyWidget(p_wContainer){<br/>
<tab></tab>Traliva.WidgetStateSubscriber.call(this, p_wContainer);<br/>
<tab></tab>this._enabled = false;<br/>
<br/>
<tab></tab>p_wContainer.setContent(Traliva.createElement(<br/>
<tab></tab><tab></tab>'&lt;p>Hello World!&lt;/p>&lt;div traliva="m_myButton" class="my_button">Не включено&lt;/div>',<br/>
<tab></tab><tab></tab>this<br/>
<tab></tab>));<br/>
<tab></tab>this.m_myButton.addEventListener('click', function(self){return function(){<br/>
<tab></tab><tab></tab>self.onBnClicked();<br/>
<tab></tab>};}(this));<br/>
};<br/>
MyWidget.prototype = Object.create(Traliva.WidgetStateSubscriber.prototype);<br/>
MyWidget.prototype.constructor = MyWidget;<br/>
MyWidget.prototype.processStateChanges = function(s){<br/>
<tab></tab>// здесь мы можем получать "пинки" от других компонентов... , но у нас нет других компонентов - это минимальный пример<br/>
};<br/>
MyWidget.prototype.onBnClicked = function(){<br/>
<tab></tab>this._enabled = !this._enabled;<br/>
<tab></tab>this.m_myButton.innerHTML = this._enabled ? 'Включено' : 'Не включено';<br/>
};<br/>
<br/>
Traliva.init({<br/>
<tab></tab>layouts: 'my_widget',<br/>
<tab></tab>widgets: {<br/>
<tab></tab><tab></tab>my_widget: MyWidget<br/>
<tab></tab>}<br/>
});
</figure>
<p>Так вот. Если у нас в объекте, передаваемом параметром в <ww>Traliva.init()</ww>, не указано свойство <ww>get_layout</ww>, то свойство <ww>layouts</ww> трактуется не как объект, в котором в разных свойствах содержатся разные лэйауты, а как сам лэйаут.</p>
<p>В примедённом выше примере не задавалось исходное состояние приложения (поскольку ну совсем примитивное веб-приложение пример описывает). Если вам нужно задать исходное состояние, но вам не нужна связь URL с объектом состояния, то не указывайте свойство <ww>tree</ww> (а также связанные с ним свойства <ww>initPath</ww>, <ww>stringifyState</ww> и <ww>_prev_values</ww>).</p>
<figure>
...<br/>
Traliva.init({<br/>
<tab></tab>...<br/>
<tab></tab>states:{<br/>
<tab></tab><tab></tab>initState: {...},<br/>
<tab></tab><tab></tab>stateSubscribers: [] // <-- это свойство также можно не указывать, если у вас нет чисто логических подписчиков<br/>
<tab></tab>}<br/>
});<br/>
...
</figure>

<a id="Низкоуровневые вещи"><h2>Низкоуровневые вещи</h2></a>
<a id="Работа с состоянием и регистрацией/обработкой его изменений"><h3>Работа с состоянием и регистрацией/обработкой его изменений</h3></a>

<p>Для обработки изменений состояния веб-приложения используются классы, отнаследованные от класса <ww>Traliva.StateSubscriber</ww> (подписчик на изменения состояния). При описании своего класса подписчика надо не забыть сделать следующие вещи:</p>
<ul>
</ul>



<p>Для обработки изменений состояния веб-приложения используются классы, отнаследованные от класса <ww>Traliva.StateSubscriber</ww> (подписчик на изменения состояния). При описании своего класса подписчика надо не забыть сделать следующие вещи:</p>
<ul>
<li>Отнаследоваться от <ww>Traliva.StateSubscriber</ww></li>
<li>В конструкторе вашего класса явно вызвать конструктор базового класса</li>
<li>Переопределить метод базового класса <ww>processStateChanges</ww> <span style="color:#666">Если метод не будет переопределён, Тралива будет ругаться в консоли - переопределение данного метода является обязательным</span></li>
</ul>
<p>Если в ходе обработки изменения состояния вы меняете объект состояние (доступен как <ww>this._state</ww>), необходимо оповестить другие подписчики об этих изменениях. Для этого вы должны после модификации состояния вызывать метод <ww>_registerStateChanges()</ww>, определённый в базовом классе.</p>
<p>Ваш подписчик должен выглядеть как-то так:</p>
<figure>
<span style="color:#666">// конструктор</span><br/>
function MyStateSubscriber(){<br/>
<tab></tab>Traliva.StateSubscriber.call(this);<br/>
<tab></tab>this._text = undefined;<br/>
}<br/>
<br/>
<span style="color:#666">// задаём наследование от класса Traliva.StateSubscriber</span><br/>
MyStateSubscriber.prototype = Object.create(Traliva.StateSubscriber.prototype);<br/>
MyStateSubscriber.prototype.constructor = MyStateSubscriber;<br/>
<br/>
<span style="color:#666">// переопределяем метод обработки изменений состояния</span><br/>
MyStateSubscriber.prototype.processStateChanges = function(s){ <span style="color:#666">// s - ссылка на объект состояния, которая всегда доступна как this._state</span><br/>
<tab></tab><span style="color:#666">// проверяем, есть ли изменения в тех свойствах состояния, которые интересуют нашего подписчика</span><br/>
<tab></tab><span style="color:#666">// если таких изменений нет, выходим</span><br/>
<tab></tab>if (s.text === this._text)<br/>
<tab></tab><tab></tab>return;<br/>
<br/>
<tab></tab><span style="color:#666">.... обрабатываем изменение свойства text объекта состояния ....</span><br/>
<tab></tab><span style="color:#666">.... this._registerStateChanges(); ....</span><br/><br/>
<tab></tab>this._text = s.text;<br/>
}
</figure>
<p>Обращаем ваше внимание на то, что реализация метода <ww>processStateChanges()</ww> состоит из двух частей:</p>
<ol>
<li>Фильтрация изменений, которые важны для данного подписчика. Если данные, за которые отвечает данный компонент, не изменились, то выходим из функции.</li>
<li>Обработка изменений</li>
</ol>
<p>Класс <ww>Traliva.WidgetStateSubscriber</ww> - это класс, отнаследованный от <ww>Traliva.StateSubscriber</ww>. Наследники класса <ww>Traliva.WidgetStateSubscriber</ww> описывают виджеты. Особенности класса <ww>Traliva.WidgetStateSubscriber</ww>: </p>
<ul>
<li>Метод <ww>processStateChanges</ww> не обязательно переопределять</li>
<li>Конструктор принимает два параметра:
    <ol>
    <li>p_wContainer - экземпляр класса Traliva.Widget, которому надо в конструкторе вызвать метод <ww>setContent</ww> с указанием виджета, лэйаута или HTML-DOM-элемент</li>
    <li>p_options - объект, описывающий параметры создаваемого виджета</li>
    </ol>
</li>
</ul>

<p>Класс <ww>Traliva.LogicsStateSubscriber</ww> - это класс, отнаследованный от <ww>Traliva.StateSubscriber</ww>. Наследники класса <ww>Traliva.LogicsStateSubscriber</ww> описывают логику (отдельные аспекты) веб-приложения. Особенностью класса <ww>Traliva.LogicsStateSubscriber</ww> является наличие метода <ww>initializeGui</ww>, который вызывается каждый раз, когда меняется лэйаут (при первой инициализации, которая происходит уже после того, как конструктор отработал, а также при изменении геометрии экрана - ресайзе браузера или повороте экрана смартфона). В этом методе можно задать видимость отдельных виджетов (они доступны в свойстве <ww>Traliva.widgets</ww>), явным образом вызывать методы виджетов.</p>
<p>Метод <ww>initializeGui</ww> класса <ww>LogicsStateSubscriber</ww> принимает два параметра:</p>
<ol>
<li>p_target</li>
<li>p_layout</li>
</ol>
<p>Это идентификаторы, характеризующие установленный лэйаут.</p>

<a id="Работа с приватными подсостояниями у подписчиков"><h4>Работа с приватными подсостояниями у подписчиков</h4></a>
<p>Внутри <ww>Traliva.StateSubscriber</ww>-а может быть размещён собственный издатель(или даже несколько, хотя потребность в этом, наверное, уже будет сигнализировать о кривизне архитектуры вашего приложения) и набор собственных (извне невидных) подписчиков. Таким образом, подписчик на изменения объекта состояния может выступать в роли прокси, прокидывая только в случае необходимости модифицированный объект состояния другим подписчикам, которые могут быть и недоступны за пределами этого подписчика.</p>
<p>Вот как примерно это выгладит:</p>
<figure>
function MyComplexSubscriber(){<br/>
<tab></tab>Traliva.StateSubscriber.call(this);<br/>
<tab></tab>this.__MyComplexSubscriber = {<br/>
<tab></tab><tab></tab>publisher: new Traliva.StatePublisher()<br/>
<tab></tab>};<br/>
<tab></tab>this.__MyComplexSubscriber.publisher.setState({<br/>
<tab></tab><tab></tab>text: 'дефолтный текст'<br/>
<tab></tab>});<br/>
<tab></tab>this.__MyComplexSubscriber.publisher.registerSubscriber(new MyFirstPrivateSubscriber());<br/>
<tab></tab>this.__MyComplexSubscriber.publisher.registerSubscriber(new MySecondPrivateSubscriber());<br/>
<tab></tab>this.__MyComplexSubscriber._selectedId;<br/>
}<br/>
MyComplexSubscriber.prototype = Object.create(Traliva.StateSubscriber);<br/>
MyComplexSubscriber.prototype.constructor = MyComplexSubscriber;<br/>
MyComplexSubscriber.prototype.processStateChanges = function(s){<br/>
<tab></tab>if (this.__MyComplexSubscriber._isSelected !== s.selected){<br/>
<tab></tab><tab></tab>this.__MyComplexSubscriber._selectedId = s.selected;<br/>
<tab></tab><tab></tab>this.__MyComplexSubscriber.publisher.setState({text: s.text[s.selected]});<br/>
<tab></tab>}<br/>
}
</figure>

<a id="Пользовательские виджеты"><h3>Пользовательские виджеты</h3></a>
<p>Пользовательские виджеты представлены классом <ww>Traliva.WidgetStateSubscriber</ww>. Для определения своего виджета вам необходимо отнаследоваться от этого класса.</p>
<p>Набор параметров вашего класса не может быть произвольным - это связано с тем, что он будет определённым образом использоваться фреймворком Тралива. Конструктор вашего класса виджета должен принимать следующие параметры:</p>
<ol>
<li>p_wContainer <span style="color:#666">- экземпляр виджета, которому ваш класс может задать свой контент. Вызовите у него метод setContent()  и передайте параметром тот виджет, который должен туда встроиться</span></li>
<li>p_options <span style="color:#666">- это объект опций виджета, указанный в объекте, описывающем виджет (Traliva.init())</span></li>
</ol>
<p>Пример виджета:</p>
<figure>
<!--function MyWidget(p_wContainer, p_options){<br/>
<tab></tab>Traliva.WidgetStateSubscriber.call(this, p_wContainer);<br/>
<tab></tab>var e = document.createElement('div');<br/>
<tab></tab>e.innerHTML = 'Нажмите сюда';<br/>
<tab></tab>p_wContainer.setContent(e);<br/>
}<br/>
MyWidget.prototype = Object.create(Traliva.WidgetStateSubscriber.prototype);<br/>
MyWidget.prototype.constructor = MyWidget;<br/>
MyWidget.prototype.processStateChanges = function(s){<br/>
<tab></tab><span style="color:#666;">....</span><br/>
}<br/>
MyWidget.prototype.onMyBnClicked = function(){
}-->
<span style="color:#666;">// Класс виджета Button. Параметром конструктора передаётся id, который должен быть записан корневое свойство объекта состояния, имя этого свойства также передаётся параметром</span><br/>
function Button(p_wContainer, p_options){<span style="color:#666;">// options: title, id, valueVarName - имя свойства, в которое сохранять значение</span><br/>
<tab></tab>Traliva.WidgetStateSubscriber.call(this, p_wContainer);<br/>
<tab></tab>var e = Traliva.createElement(p_options.title);<br/>
<tab></tab>e.className = 'bn';<br/>
<tab></tab>e.addEventListener('click', function(self, opt){return function(){<br/>
<tab></tab><tab></tab>self._state[opt.valueVarName] = opt.id;<br/>
<tab></tab><tab></tab>self._registerStateChanges();<br/>
<tab></tab>};}(this, p_options));<br/>
<tab></tab>p_wContainer.setContent(e);<br/>
}<br/>
Button.prototype = Object.create(Traliva.WidgetStateSubscriber.prototype);<br/>
Button.prototype.constructor = Button;
</figure>
<p>Класс <ww>Traliva.WidgetStateSubscriber</ww> наследуется от <ww>Traliva.StateSubscriber</ww>, но, в отличие от последнего, допускает непереопределение метода <ww>processStateChanges()</ww>.</p>

<!--<h4>Простые виджеты</h4>
<h4>Составные виджеты</h4>-->
<a id="API работы с лэйаутами"><h3>API работы с лэйаутами</h3></a>
<p>Здесь будут рассмотрены компоненты для создания лэйаутов "руками", то есть не в декларативном стиле, а в императивном. Эти компоненты используются в реализации функции <ww>Traliva.init()</ww>, но могут быть полезны и использующему данный фрэймворк программисту.</p>
<p>Все виджеты наследуются от класса <ww>Traliva._WidgetBase</ww>. Этот класс принимает два необязательных параметра - родительский виджет, и (строка)скрывать ли ту часть контента, что не уместилась в отведённую для виджета область (если не скрывать, то по мере необходимости будут появляться полосы прокрутки; По горизонтали и по вертикали можно задавать разные политики появления полос прокрутки, возможные значения: ''(по умолчанию), 'v', 'h', 'vh')). Если не указан родительский виджет, то этот виджет будет отслеживать изменения размеров области отображения браузера и подгонять под эти размеры свои размеры. Если родительский виджет указан, то тот виджет по мере необходимости должен вызывать метод _onResized(w, h) дочерних виджетов. Таким образом, изменения размеров области отображения отслеживаются только виджетов верхнего уровня, а все его дочерние виджеты рекурсивно явно меняют размеры своих дочерних виджетов.</p>
<p>То, что имя класса <ww>Traliva._WidgetBase</ww> начинается со знака подчёркивания, означает, что этот класс не может использоваться без наследования (это виртуальный класс).</p>
<p>Особый класс виджета - <ww>Traliva.Widget</ww> - это контейнер. Сюда может быть установлен другой виджет или объект DOM-модели документа (HTML-элемент). Экземпляр этого класса передаётся как параметр конструкторам виджетов (например, <ww>Traliva.WidgetStateSubscriber</ww>), чтобы те установили туда нужный контент. Дело в том, что мы можем сначала установить виджет в лэйаут, и лишь потом вызвать конструктор виджета, чтобы тот вписал контент в виджет с уже становленными размерами.</p>
<p>Метод для установки содержимого - <ww>setContent</ww> - принимает два параметра:</p>
<ol>
<li>сам добавляемый виджет или HTML-элемент. Можно и <ww>undewfined</ww> передать...</li>
<li>(строка) цвет фона (например, '#ffa' или 'red')</li>
</ol>
<a id="Класс Traliva.Strip"><h4>Класс Traliva.Strip</h4></a>
<p>Это виджет, аналог классов <ww>QVBoxLayout</ww> и <ww>QHBoxLayout</ww> из состава фрэймворка <ww>Qt</ww> в одном лице. Принимает три параметра:</p>
<ol>
<li>p_orient - это обязательный параметр, который задаёт ориентацию лэйаута. Возможные значения: <ww>Traliva.Strip__Orient__hor</ww> и <ww>Traliva.Strip__Orient__vert</ww>.</li>
<li>p_parentWidget - родительский виджет</li>
<li>p_attr - второй параметр, который передать базовому классу <ww>Traliva._WIdgetBase</ww></li>
</ol>
<p>Для добавления элементов в лэйаут предназначен метод <ww>addItem</ww>, который принимает два параметра: добавляемый виджет (HTML-элемент - это не виджет!) и размер (строка, единицы измерения - 'px' или 'part'. По умолчанию, '1part'.)</p>
<p>Для изменения размеров элементов виджета предназначен метод <ww>setItemSize</ww>. Этот метод принимает параметром объект, в котором в свойствах порядковому номеру элемента ставится в соответвие новое значение полоитики размеров. Например,</p>
<figure>
wRoot.setItemSize({0:'2part'});
</figure>

<a id="Класс Traliva.Stack"><h4>Класс Traliva.Stack</h4></a>

<p>Это виджет, аналог класса <ww>QStackedWidget</ww> из состава фрэймворка <ww>Qt</ww> - контейнер, располагающий дочерние виджеты один поверх другого. </p>
<p>Принимает два параметра - как у класса <ww>Traliva._WidgetBase</ww>.</p>
<p>Для добавления элемента предусмотрен метод <ww>addItem</ww>, который принимает единственный параметр - добавляемый виджет, и который добавляет виджет всегда поверх всех добавленных ранее.</p>
<p>Есть метод, удаляющий дочерний виджет по порядковому номеру - <ww>removeItem</ww>.</p>

<a id="Утилиты"><h3>Утилиты</h3></a>
<a id="Traliva.createElement()"><h4>Traliva.createElement()</h4></a>
<p>Функция <ww>Traliva.createElement()</ww> возвращает DOM-элемент (тэг <ww>div</ww>), внутри которого находится переданный параметром HTML-код.</p>
<p>Принимает следущие параметры:</p>
<ol>
<li>HTML-код (тип строка)</li>
<li>необяз.; объект, в котором сохранить экземпляры созданных дочерних DOM-элементов (тип Объект)</li>
<li>необяз.; CSS-класс, который нужно задать создаваемому DOM-элементу</li>
</ol>
<p>Насчёт второго параметра - объекта, в котором сохранять экземпляры созданных дочерних DOM-элементов. В нём сохраняются только те элементы, для которых в HTML-коде указано значение атрибута <ww>traliva</ww>. Пример:</p>
<figure>
var obj = {};<br/>
var e = Traliva.createElement(<br/>
<tab></tab>'&lt;p class="my_p" traliva="title">&lt;/p>&lt;p traliva="pair">&lt;span traliva="first">&lt;/span> - &lt;span traliva="second">&lt;/span>&lt;/p>',<br/>
<tab></tab>obj,<br/>
<tab></tab>'my_div');
</figure>
<p>Что мы имеем в данном примере:</p>
<ul>
<li><ww>e</ww> - DOM-элемент (тэг <ww>div</ww>), CSS-класс у него <ww>my_div</ww>, в нём находятся два элемента с тэгом <ww>p</ww>, во втором из них два элемента с тэгом <ww>span</ww></li>
<li>У объекта <ww>obj</ww> появились четыре свойства: <ww>title</ww>, <ww>pair</ww>, <ww>first</ww> и <ww>second</ww> - это DOM-элементы, входящие в состав DOM-элемента <ww>e</ww>.</li>
</ul>
<a id="Traliva.ajax()"><h4>Traliva.ajax()</h4></a>

<p>Функция <ww>Traliva.ajax</ww> загружает данные с сервера. Всегда асинхронно. Принимает параметром объект, который может иметь следующие свойства:</p>
<ul>
<li>sourcePath - (string) сетевой адрес, откуда производить загрузку данных, это свойство обязательно должно быть задано</li>
<li>readyFunc - (function(result)) эта функция будет вызвана, когда result будет успешно получен от сервера</li>
<li>errorFunc - (function(isNetworkProblem)) эта функция будет вызвана в случае, если получить данные от сервера не получилось. Параметр <ww>isNetworkProblem</ww> - (boolean) связана ли ошибка с отсутствием сетевого соединения.</li>
<li>timeout - максимальное время ожидания ответа от сервера в милисекундах. По умолчанию равно 3000 (3 секунды).</li>
<li>dataToPost - данные, которые нужно передать на сервер. Если данные для отсылки есть, то будет POST-запрос, если нет - GET.</li>
<li>addonHttpHeaders - объект, в котором по ключ-значение лежат заголовки http-запроса, которые необходимо добавить в отправляемый на сервер запрос</li>
</ul>

<a id="Отладка"><h2>Отладка</h2></a>
<p>Если перед вызовом функции <ww>Traliva.init()</ww> задать значение переменной <ww>Traliva.debug</ww>, то Тралива построит веб-приложение в режиме отладки - помимо самого веб-приложения, будет отображаться также панель, из которой можно открыть на просмотр/редактирование объект состояния веб-приложения.</p>
<figure>
Traliva.debug = {<br/>
<tab></tab>states: true,<br/>
<tab></tab>url: 'traliva.ru'<br/>
};<br/>
Traliva.init({<br/>
<tab></tab>...<br/>
});
</figure>
<img src="debug_0.png"/>
<img src="debug_1.png"/>
<p>Помимо опций <ww>states</ww> и <ww>url</ww> также поддерживаются следующие опции:</p>
<ul>
<li><ww>unintialized_colored</ww> - у всех виджетов, которым не задан конкретный класс виджета (в свойстве <ww>widgets</ww>), появляются уникальные цвета фона. Если у виджета в лэйауте указан идентификатор, то он в случае неинициализированности будет отображаться в "расцвеченном" виде вне зависимости от того, указано ли свойство <ww>unitialized_colored</ww>.</li>
</ul>
<p>Если пользователь поменял состояние в виджете отладки, то для того, чтобы изменения попали в веб-приложение, необходимо нажать кнопку <ww>'Применить'</ww></p>
<p>Помимо возможности видеть и редактировать объект состояния, в режиме отладки может быть активирован режим имитации сервера. Эта опция предназначена для разработки веб-приложения в локальной файловой системе - в панели отладки отображается строка с URL, который был бы, если бы данное веб-приложение было запущено с сервера (здесь можно отлаживать отображение URL в состояние и состояние в URL).</p>
<p>В разделе "Продолжения" указывается текущее активное продолжение веб-приложения.</p>


<!--<h2>Низкоуровневые вещи</h2>
Три составляющие:
<ul>
<li>Классы для работы с состояниями. Паттерн "Подписчик-издатель" для изменений в едином объекте, описывающем состояние всего веб-приложения.</li>
    <ul>
    <li><ww>StatePublisher</ww> "Издатель" - экземпляр этого класса оповещает подписчиков об изменении Состояния.</li>
    <li><ww>StateSubscriber</ww> Класс для наследования. "Подписчик". Обрабатывает изменения Состояния и регистрирует свои изменения.</li>
    <li><ww>StateDebugWidget</ww> Подписчик, который в реальном времени отображает Состояние внутри указанного div-а (DomElement).</li>
    <li><ww>StateToUriMapper</ww> Подписчик, который отображает Состояние в URL и обратно - при смене URL соответвующим образом меняет объект Состояния. Конструктор параметром принимает объект, описывающий соответствие подкаталогов URL-а значениям отдельных полей в объекте Состояния.</li>
    </ul>
<li>Классы для построения GUI. События изменения размеров виджетов прокидываются сверху вниз - от браузера к виджету верхнего уровня, и далее к его дочерним виджетам. Также прокидываются события изменения видимости, и есть свой метод для переопределения onScrolled.</li>
    <ul>
    <li><ww>_WidgetBase</ww> Класс для наследования. Наследуйтесь от этого класса, если хотите написать свой контейнер виджетов. Под виджетом понимается наследник этого класса.</li>
    <li><ww>Widget</ww> Контейнер одного элемента, который можно передавать StateSubscriber-ам для установки ими туда другого виджета или DOM-элемента.</li>
    <li><ww>Strip</ww>  Контейнер виджетов: Горизонтальный или вертикальный лэйаут.</li>
    <li><ww>Stack</ww>  Контейнер виджетов: Многослойный.</li>
    </ul>
<li>Отдельные функции общего назначения</li>
    <ul>
    <li><ww>ajax</ww>  - обёртка над XmlHttpRequest для простого выполнения асихронных HTTP-запросов.</li>
    <li><ww>checkVisible </ww> - эта простенькая функция вам понадобится, если вы будете делать динамическую подгрузку контента при прокручивании контента.</li>
    </ul>
</ul>-->

<a id="Лицензия"><h2>Лицензия</h2></a>

<p>Copyright © 2017-2018 <a href="https://github.com/1024sparrow">Васильев Борис</a><br/>
Публикуется под лицензией <a href="https://github.com/1024sparrow/traliva/blob/master/LICENSE">MIT license</a>.</p>
