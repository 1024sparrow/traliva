<!-- codepage utf-8 -->
<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
</head>
<body>

<h1>Предложения к спецификации Тралива</h1>

<a id="Подгрузка частей веб-приложения"><h2>Подгрузка частей веб-приложения</h2></a>
<p>У нас пока получается так, что мы должны сразу создать все виджеты, которые у нас могут использоваться в текущем лэйауте, и во время работы веб-приложения только менять видимость созданных ранее виджетов.</p>
<p>Приведу пример. Пусть мы хотим в нашем веб-приложении разместить кнопку "Авторизоваться". Мы должны в лэйаут типа 'stack' положить виджеты всех диалоговых окон, которые нам потребуются во время авторизации (а у пользователя ведь может и не быть учётки, и надо будет регистрироваться...) - нельзя ли сделать динамическую подгрузку логики и GUI авторизации лишь по нажатию на пнопку "Авторизоваться"? Вот типичный случай, когда нам потребуется свойство <ww>extender</ww>(объект) - в нём мы указываем подсостояние, где Traliva должен мониторить значение строкового идентификатора A, и функцию, которая по значению A даёт лэйауты, виджеты и состояния. Как работать с <ww>extender</ww> описано ниже в разделе 'Подгрузка частей веб-приложения'.</p>


<p>Свойство <ww>extender</ww> объекта, передаваемого параметром в функцию <ww>Traliva.init()</ww>, отвечает за динамическую подгрузку части веб-приложения.</p>
<p>Объект <ww>extender</ww> имеет следующие свойства:</p>
<ul>
<li><ww>substate</ww> - подсостояние, которое Тралива должен мониторить. Если значение в подсостоянии (назовём это значение "id_подсостояния") изменилось, это значение будет передано в <ww>getUrl</ww></li>
<li><ww>getUrl</ww> - функция, которая принимает параметром id_подсостояния, возвращает URL, по которому Тралива должен подгрузить часть веб-приложения</li>
<li><ww>ifSave</ww> - сохранять ли загруженный код при смене продолжения (<ww>true</ww> или <ww>false</ww>)</li>
</ul>
<p>По указанному URL Тралива загружает JavaScript-код, создающий объект, имеющий следующие поля:</p>
<ul>
<li><ww>layouts</ww></li>
<li><ww>widgets</ww></li>
<li><ww>states</ww></li>
<li><ww>extender</ww></li>
<li><ww>hideWidgets</ww></li>
</ul>
<!--<p>Смысл свойств этого объекта такой же, как и у одноимённых свойств объекта, передаваемого функции <ww>Traliva.init()</ww>. Как вы уже могли заметить, подгружаемый код может продолжить подгрузку дальше.</p>-->
<!--<p>В каждый момент времени можно иметь динамически подгруженным не более одного "продолжения веб-приложения" - всё дело в том, что это "продолжение" должно достроить URL.</p>-->
<p>Приведу пример. Опять авторизация. У нас сайт, на нём вкладки "каталог", "справка" и "личный кабинет"(авторизация). В лэйауте у нас есть элемент типа <ww>widget</ww>, где размещается виджет с идентификатором <ww>'myWidget'</ww>. Когда пользователь нажимает на вкладку "каталог", в объекте состояния меняется (мы меняем в коде кнопки, которую пишем для вкладки) свойство <ww>currentTabId</ww> на <ww>'catalogue'</ww>. Это подсостояние (<ww>'currentTabId'</ww>) у нас указано у <ww>extender</ww> - для идентификатора подсостояния <ww>'catalogue'</ww> Тралива подгрузит объект с <ww>layouts</ww>, <ww>widgets</ww>, <ww>states</ww>, <ww>hideWidgets</ww> и, возможно, <ww>extender</ww>, после чего применит загруженное. Давайте рассмотрим, как используются эти данные.</p>
<subdiv>
<p>В нашем текущем лэйауте уже есть элементы типа <ww>'widget'</ww>, у которых указан идентификатор. Так вот, если свойство, одноимённое этому идентификатору, есть в свойстве <ww>layouts</ww> загруженного объекта, то Тралива создаёт соответствующий составной виджет в соответвующее место в лэйауте (если там уже был установлен виджет, он уничтожается). Далее, по идентификаторам виджетов, указанных в загруженном лэйауте, Тралива берёт конструкторы виджетов в свойстве <ww>widgets</ww>.</p>
</subdiv>
<subdiv>
<p>Свойство <ww>states</ww> имеет тот же смысл, что и у объекта, передаваемого в функцию <ww>Traliva.init()</ww>. Подписчики изменений состояния приложения работают с объектом состояние веб-приложения, так же как и любые подписчики изменения состояния.</p>
<p>Есть изменения в свойстве <ww>states</ww> - <ww>initState</ww> не используется, вместо этого появляются два новых свойства: <ww>in</ww> и <ww>out</ww> - это функции, модифицирующие объект состояния веб-приложения при загрузке и выгрузке части веб-приложения соответственно.</p>
<p>Обратите внимание на то, что у объекта <ww>states</ww> свойство <ww>initPath</ww> уже не может ссылаться на корень - мы должны указать ту часть URL, которая актуальна только в случае этого "продолжения". Эту часть URL Тралива будет продолжать согласно свойству <states> "продолжения". Будьте аккуратны со свойством <ww>initPath</ww> - здесь, как когда-то где-то видел в комментариях, "тонкий лёд".</p>
</subdiv>
<subdiv>
<p>Подгружаемый код может продолжить подгрузку дальше. Нет ограничений на количество отдельных подгружаемых частей. Есть лишь то ограничение, что все подгружаемые части выстроены в единую иерархическую структуру (технически невозможно это ограничение обойти) - это связано с тем, что Тралива должен создать URL (т.е. не может быть нескольких частей на одном уровне одновременно: у нас выбрана одна вкладка, и в ней уже выбрана другая вкладка, но не так, что у нас выбраны такая и такая вкладки(если нужно так, то сделайте <ww>MxN</ww> вариантов частей для подгрузки, но всё равно идентификатор совокупности параметров(вкладок) должен быть один)).</p>
<p>Приведу пример. Вы зашли на сайт. Перешли на вкладку "каталог" - подгрузилась соответвующая часть(виджеты наполнились контентом, подключились <ww>Traliva.StateSubscriber</ww>-ы, модифицировалось состояние веб-приложения, URL страницы продолжен в соответствии с <ww>states.stringifyState</ww>). На вкладке "каталог" появились вкладки <ww>лодки</ww> и <ww>палатки</ww>. При переключении на <ww>палатки</ww> подгружается следующая часть веб-приложения, которая относится к предыдущей загруженной как дочерняя.</p>
<p>Таким образом, если нам надо будет добавить новую вкладку, нам практически не надо будет модифировать код - просто добавть новый подгружаемый модуль.</p>
<p>Теперь рассмотрим, что происходит при переключении вкладки, т.е. почему части веб-приложения выстроены в иерархическую структуру.</p>
<p>Продолжим рассматривать наш пример. Вот пользователь смотрит вкладку "палатки" на вкладке "каталог".</p>
<p>Если пользователь переключит вкладку с "палатки" на "лодки", то<ol><li>"продолжение", загруженное для "палатки", должно выгрузиться - уничтожаются созданные в рамках того продолжения виджеты, уничтожаются <ww>Traliva.StateSubscriber</ww>-ы, к объекту состояния веб-приложения применяется функция <ww>states.tree.out</ww> выгружаемой части веб-приложения</li><li>Инициализируется новое "продолжение" - строятся виджеты, создаются и подписываются новые подписчики, соответвующим образом модифицируется объект состояния (исполняется <ww>states.tree.in</ww> подгружаемой части), перестраивается URL.</li></ol></p>
</subdiv>
<subdiv>
<p>Что должно происходить при смене продолжения: должны ли мы удалить виджеты и классы логики, относящиеся к предыдущему продолжению, или, может, только деактивировать логику и скрыть виджеты, или и виджеты скрывать не нужно (но "заморозка" логики всё-же неизбежна). Такое поведение задаётся двумя параметрами:</p>
<ul>
<li>свойством <ww>ifSave</ww> объекта <ww>extender</ww></li>
<li>свойством <ww>hideWidgets</ww> объекта, загружаемого по указанному в <ww>extender</ww>-е адресу</li>
</ul>
<p>Свойство <ww>ifSave</ww> может принимать значения <ww>true</ww> или <ww>false</ww> (<ww>false</ww> по умолчанию). Если <ww>true</ww>, то при смене продолжения не будет удалён код, загруженный для предыдущего продолжения (производится кэширование загруженного ранее кода) - не будут удалены как классы виджетов и логики, так и сами виджеты как DOM-элементы. Однако в любом случае виджеты и классы логики будут исключены из списка подписчиков на изменения состояния - до тех пор, пока их продолжение не будет вновь активировано.</p>
<p>Свойство <ww>hideWidgets</ww> используется тогда, когда задано <ww>true</ww> у свойства <ww>ifSave</ww>. Значение по умолчанию отсутствует - т.е. если <ifSave> задано в <ww>true</ww>, а свойство <ww>hideWidgets</ww> не задано, это является ошибкой. Возможные значения свойства <ww>hideWidgets</ww>:</p>
<ul>
<li><ww>true</ww> - при деактивации продолжения виджеты скрываются (становятся невидимыми)</li>
<li><ww>false</ww> - при деактивации продолжения виджеты не скрываются</li>
<li><ww>{hide: true, exceptions: ['myWidget', ...]}</ww> - скрывать все виджеты за исключением тех, чьи идентификаторы перечислены в свойстве <ww>exceptions</ww></li>
<li><ww>{hide: false, exceptions: ['myWidget', ...]}</ww> - скрывать только те виджеты, чьи идентификаторы перечислены в свойстве <ww>exceptions</ww></li>
</ul>
</subdiv>
<p>Отдельных слов заслуживает область действия идентификаторов виджетов. В объекте, передаваемом параметром в функцию <ww>Traliva.init()</ww>, идентификаторы виджетов, указанные в свойстве <ww>widgets</ww>, соответвуют объектам, описывающим лэйауты в свойстве <ww>layouts</ww>, для продолжения. Идентификаторы виджетов, указанные в свойстве <ww>widgets</ww> объекта, загруженного для продолжения, соответствуют объектам, описывающим лэйауты в свойстве <ww>layouts</ww> объекта, загружаемого продолжения продолжения. И так далее. Таким образом, идентификаторы виджетов не обязаны быть уникальными в рамках всего веб-приложения - они должны быть уникальными только в пределах своего продолжения (<ww>Traliva.init()</ww> можно трактовать как продолжение нулевого уровня).</p>

<h2>Автоподгон размеров виджетов под содержимое, дополнения к политике размеров виджетов</h2>
<p>Это относится только к определению размеров в контейнере виджетов Stack (ну и всплывающих виджетов(см. следующее предложение)).</p>
<p>Сейчас размеры элемента в контенере Stack задаются как фиксированные в пикселях (32px) или как занимающие заданную часть от оставшегося после фиксированных элементов места (2part). Так вот, есть предложение расширить такую политику следующим образом:</p>
<ul>
<li>В класс _WidgetBase добавить метод sizeHint(), который должен возвращать минимальный размер, который требуется для того, чтобы контент виджета умещался. Дефолтная реализация - пробно отрисовать и посмотреть, сколько места занимает HTML-код.</li>
<li>Если требуется переопределение sizeHint-а, это делать в коде WidgetStateSubscriber-а</li>
<li>В класс _WidgetBase добавить метод sizeHintChanged() как сигнал, на который может подписаться родительский контейнер.</li>
<li>Не забыть переопределить (сбросить в дефолт) метод sizeHintChanged() при извлечении виджета из контейнера</li>
<li>Помимо px и part добавить спецслово ftc (Fit To Content), которое бы означало, что элемент должен занимать столько места, сколько указано в sizeHint-е</li>
<li>Добавить возможность задавать минимальные и максимальные размеры (min и max). Например, '2part;min:32px' означает 2 части от оставшегося места, но не менее 32 пикселей. Если отставшегося места в Strip-е недостаточно для задания нужного размеров элементам, у Strip-а должна появиться прокрутка (или не появиться в соответствии с политикой scroll).</li>
</ul>

<h2>Всплывающие виджеты и тултипы</h2>
<p> В класс WidgetStateSubscriber добавить метод setPopup(). Принимаемые параметры: </p>
<ol>
<li>Опорный виджет. Это может быть this или какой-то из его дочерних виджетов. Возможные типы этого параметра: WidgetStateSubscriber(в качестве опорного виджета берётся его _wContainer), _WidgetBase, DomElement.</li>
<li>Тип. Варианты:
    <ul>
    <li>'t' - Всплытие как тултип, т.е. отталкиваясь от позиции курсора</li>
    <li>'h' - Всплытие рядом по горизонали (в зависимости от того, где больше свободного места, справа или слева (при равных будет отображаться справа))</li>
    <li>'hl' - как при 'h', но при равных делать предпочтение на отображение слева</li>
    <li>'v' - Всплытие рядом по вертикали (в зависимости от того, где больше свободного места, сверху или снизу (при равных будет отображаться снизу))</li>
    <li>'vt' - как при 'v', но при равных делать предпочтение на отображение сверху</li>
    <li>'vh' - атоматическое определение, всплывать рядом по горизонтали или по вертикали</li>
    </ul>
    <p>При всплытии по горизонтали координата по вертикали по возможности выравнивается к верхнему краю опорного виджета</p>
</li>
<li>Всплывающий виджет. Может иметь один из следующий типов:</li>
<ul>
<li>Объект, как при описании виджета (свойства widget, substate и popup) или WidgetStateSubscriber. В таком случае виджет появляется сразу, как только заданное подсостояние валидно, и уничтожается, когда подсостояние становится невалидным</li>
<li>_WidgetBase</li>
<li>DOM-элемент</li>
<li>Текст</li>
</ul>
</ol>
<p>Время жизни и видимость всплывающего виджета привязаны к опорному виджету - как только опорный виджет меняет видимость, всплывающий виджет так же меняет свою видимость, при уничтожении опорного виджета уничтожается и всплывающий виджет (и всплывающие из всплывающего виджета также соответственно)</p>
<p>Всплывающие виджеты, для которых не указано подсостояние (которые перманентные), должны иметь возможность быть досрочно уничтожены путём вызова setPopup() с такими же типом и опорным виджетом, но с незаданным (или заданным как undefined) самим всплывающим виджетом.</p>
<p>Таким образом, для задания тултипа виджету в WidgetStateSubscriber-е необходимо прописать this.setPopup(this, 't', 'Текст тултипа').</p>
<p>В описании формата описания виджета необходимо добавить свойства popup, которое есть массив(или единственный экземпляр) из {объектов со свойствами type и widget} или {строк}. Строка, переданная в качестве popup, должна интерпретироваться как тултип.</p>
<p>Про реализацию всплывающих виджетов. Корневой виджет веб-приложения - Stack, в который добавляются главный лэйаут и виджет, на котором будут отображаться всплывающие виджеты. Сейчас пробрасываются события изменения размеров виджетов, надо, чтобы пробрасывались также и события изменения экранного положения виджетов.</p>

</body>
</html>
