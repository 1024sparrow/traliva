<html>
<head>
<meta charset="utf-8"/>
<title>Синтаксический сахар</title>
<link rel="stylesheet" type="text/css" href="style/style.css">
</head>
<body>
<a href="../index.html" style="font-size=2em;color:#f60;border:1px solid #f60;border-radius:5px;">НАВЕРХ</a>
<h1>Синтаксический сахар</h1>
<p>Поскольку код на ECMAScript 5 компилируется (нашим <a href="https://github.com/1024sparrow/compiler">компилятором</a>), то есть возможность введения дополнительных языковых конструкций, которые после компиляции кода будут преобразованы в обычный es5-код.</p>
<h2>Перечисления и битовые маски</h2>
<p>Перечисление - это <a href="https://ru.wikipedia.org/wiki/%D0%9F%D0%B5%D1%80%D0%B5%D1%87%D0%B8%D1%81%D0%BB%D1%8F%D0%B5%D0%BC%D1%8B%D0%B9_%D1%82%D0%B8%D0%BF">перечисляемый тип</a>.</p>
<p>Объявление перечисления - <hl>#ENUM#имя_перечисления:поле_1,поле_2##</hl> . Использование пробельных символов (здесь и далее) внутри обрамления символами # не допускается.</p>
<p>Использование в коде - <hl>#e#имя_перечисления:имя_поля##</hl> .</p>
<p>Проверка соответствия значения переменной перечислению - <hl>переменная & #e#имя_перечисления##</hl>.</p>
<p>Битовая маска - это перечисляемый тип, все значения элементов которого бинарно не пересекаются. Это степени двойки - 1 (1), 2 (10), 4 (100), 8 (1000), 16 (10000) и т.д. Применимо для хранения набора флагов, которые могут использоваться как по-отдельности, так и совместно, с использованием побитовых операций &, |, ~, а также операции побитового инверирования !.</p>
<p>Объявление перечисления с битовыми масками - <hl>#MASK#имя_перечисления:поле_1,поле_2##</hl> .</p>
<p>Использование в коде - <hl>#m#имя_перечисления:имя_поля##</hl> .</p>
<p>Проверка соответствия значения переменной перечислению с битовыми масками - <hl>переменная & #m#имя_перечисления##</hl> (код, обрамлённый #, преобразуется в функцию).</p>
<p>Ещё один тип данных - атом (заимствован из языка <a href="http://rsdn.org/article/erlang/GettingStartedWithErlang.xml#EVBAC">erlang</a>). Атом - это поле глобального анонимного перечисления.</p>
<p>Объявления атома - <hl>#ATOM#имя_атома##</hl> .</p>
<p>Использование атома - <hl>#a#имя_атома##</hl> .</p>
<p>Объявление используемых атомов и перечислений необходимо для возможности проверки кода на предмет опечаток на этапе компиляции, а также возможности ограничить область их действия.</p>
<p>Тип файла для таких преобразований - 'js_sugar'. Следует указывать только при окончательной сборке (все идентификаторы будут уникальны только в рамках собираемого файла).</p>
<p>Во что преобразуются перечисления при компиляции - в 4-байтное число. Младший байт идентифицирует само перечисление (их по коду не может быть более 255 (нулевое значение зарезервировано для "безымянных" перечислений - атомов)). Старшие три байта используются используются для определения значения поля в рамках перечисления: просто перечислений могут иметь до 16.7 млн полей, а вот перечисления с битовыми масками - только до 24-х.</p>
<h2>Разметка для минификации кода</h2>
<h3>Подмена имён переменных на более короткие</h3>
<p>Имена используемых переменных, подлежащих замене на более короткие при компиляции, необходимо предварять симолом $. Имя переменной считается от символа $ до первого символа, не входящего в множество (буквы, цифры, символ _).</p>
<c>var $impedanse = 5;</c>
<p>Подмена имён работает как для имён переменных, так и для названий полей объектов, в том числе внутри строк (например, JSON) - анализ контекста использования не производится.</p>
<p>Тип файла для таких преобразований - 'name_min'. В списке типов файла следует указывать после всех тех типов, которые используют символ $ для синтаксических преобразований.</p>
<h3>Разметка для анализатора используемости кода</h3>
<p>Используются метки, обозначающие начало блока кода, конец блока кода и признак (строковый идентификатор), который должен быть активирован, если пользователю понадобится использовать код, закреплённый за этой меткой (активация может быть произведена и перед тем, как код будет определён). Признак (идентификатор блока кода) может содержать символ "$", буквы, точки и цифры в любой последовательности, но не может быть пустым.</p>
<p>Активация метки присходит лишь на этапе компиляции, так что даже если активацию программист засунул в условие (не надо так делать!), которое никогда не выполняется, активация всё равно будет произведена.</p>
<c>#USAGE_BEGIN#$Traliva.$Strip.user_resize##
....
....
#USAGE_END#$Traliva.$Strip.user_resize##
</c>
<p>Как использовать (активировать) функцию, описанную в вышеописанном блоке:</p>
<c>#u#$Traliva.$Strip.user_resizes##
</c>
</body>
</html>
