Поиграйтесь с примерами.
------------------------

После того как склонировали репозиторий traliva, вам необходимо выполнить находящийся там скрипт init_submodules.sh

src/ - исходники traliva
src/build_scripts/targets/ - директория с правилами сборки под разные платформы (они хранятся в отдельных репозиториях)
src/project_compiled/ - директория с бессерверным вариантом сборки (для разработчика)
compiled/ - результат компиляции исходников. Это ещё не рузультат разработки.
targets/ - проекты под разные платформы. Это копия из compiled, модифицируемая программистом.

Сборка:
compile src/pro - сборка под платформы. Бессерверный вариант не собирается.
compile src/project/project.pro - сборка бессерверной части (для разработчика). Под платформы код не формируется.

Создайте свой проект.
---------------------
Ваш проект - это ваш проект. И для начала вам необходимо сделать своё ответвление проекта.
Т.е. вы не клонируете проект с github-а, а инициализируете новый репозиторий, и сливаете туда код из репозитория с github-а, либо клонируте уже ваш собственный ранее созданный репозиторий. Инициализация такого репозитория называется fork. Ниже описывается процедура fork:
Допустим, ваш проект называется abc. В выбранной для проекта директории (которая, наверное, так и называется - abc) выполните следующие команды:

$ mkdir repos && cd repos
repos$ for i in {abc,abc_kit,abc_proj}; do git init --bare --shared $i.git; done
repos$ cd ..
$ git clone repos/abc.git && cd abc
abc$ git remote add parent_github https://github.com/1024sparrow/traliva.git
abc$ git remote set-url parent_github --push "Вы не можете заливать изменения в репозиторий родительского проекта"
abc$ git pull parent_github master
abc$ git push --set-upstream origin master
abc$ vim .gitmodules
 здесь мы заменяем адреса гитхабовские на свои собственные
    [submodule "project"]
        path = src/project
-       url = https://github.com/1024sparrow/traliva_example.git
+       url = ../abc_proj.git - относительные пути - относительно пути расположения репозитория abc.git
        branch = master
    [submodule "traliva_kit"]
        path = traliva_kit
-       url = https://github.com/1024sparrow/traliva_kit.git
+       url = ../abc_kit.git
        branch = master

abc$ ./init_submodules.sh
abc$ pushd traliva_kit
abc/traliva_kit$ git remote add parent_github https://github.com/1024sparrow/traliva_kit.git
abc/traliva_kit$ git remote set-url parent_github --push "Вы не можете заливать изменения в репозиторий родительского проекта"
abc/traliva_kit$ git pull parent_github master
abc/traliva_kit$ git push --set-upstream origin master
abc/traliva_kit$ popd
abc$ pushd src/project
abc/src/project$ git remote add parent_github https://github.com/1024sparrow/traliva_example.git
abc/src/project$ git remote set-url parent_github --push "Вы не можете заливать изменения в репозиторий родительского проекта"
abc/src/project$ git pull parent_github master
abc/src/project$ git push --set-upstream origin master
abc/src/project$ popd
abc$

Когда выходит новая версия Traliva
----------------------------------
Будьте осторожны с обновлением Traliva: необходимо сохранить резервную копию директории с вашим проектом - просто скопируйте директорию abc. Репозитории копировать не надо - пока вы изменения не за-push-ите, там ничего сломаться не может.
Процедура получения обновлений из родительского проекта (который вы в своё время форкнули) следующая: заходите в соответствующую директорию и выполняете git pull parent_github <ветка>. Обновление всего: сначала обновляете корневой проект (потомок traliva.git), затем выполняете скрипт init_submodules.sh, и только потом обновляете отдельно каждый подмодуль (потомки traliva_kit.git и traliva_example.git).



===============================================

<!DOCTYPE html>
<!--[if IE]><![endif]-->
<!--[if IE 8 ]><html dir="ltr" lang="ru" class="ie8"><![endif]-->
<!--[if IE 9 ]><html dir="ltr" lang="ru" class="ie9"><![endif]-->
<!--[if (gt IE 9)|!(IE)]><!-->
<html dir="ltr" lang="ru">
<!--<![endif]-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, user-scalable=0">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<title>Уличный стиль и минимализм | Одежда из натуральных тканей | Гнездо Маркет</title>
<base href="https://gnezdo-market.ru/" />
<meta name="description" content="Одежда с дизайнерскими принтами – лимитированные коллекции, экологичные материалы, минимализм. 
Без котиков и сисек, но в центре внимания!" />
<meta name="keywords" content= "дизайнерская одежда, футболки, свитшоты, платья, мандалы, принты, минимализм, уличный стиль, экологичные материалы " />
<meta property="og:title" content="Уличный стиль и минимализм | Одежда из натуральных тканей | Гнездо Маркет" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://gnezdo-market.ru/" /><meta property="og:image" content="https://gnezdo-market.ru/image/catalog/gnezdo/og_image.png" />
<meta property="og:site_name" content="Гнездо Маркет" />

/robots.txt

----------------------------------------------

    Traliva.debug = true;
    var Traliva__log__re = /\(([^\)]*)\)/gi;
    Traliva.log = function(){
        var $0, error, $1;
        if (Traliva.debug){
            error = new Error();
            $0 = error.stack.match(Traliva__log__re);
            $1 = Array.prototype.slice.call(arguments);
            $0 = $0[1];
            $1.unshift($0.substr(1, $0.length - 2) + ':\n');
            console.log.apply(console, $1);
        }
    };

    Traliva.log('update arrows data:', s.data);//

----------------------------------------------


defineContext([], function(App){

/*
 * Обёртка над Traliva.ajax
 * Обеспечивает получение ответов от сервера в том же порядке, как посылались запросы.
 * Запросы выполнять методом  request().
 * Метод break() "отменяет" все ранее сделанные запросы (ответы игнорируются) и возвращает число "отменённых" запросов.
 * Если в качестве URL передать '_fake', то объект, переданный на вход, будет выдан на выход без каких-либо запросов на сервер.
 *
 * Требования к серверному коду (python):
 * 1. На выход должен всегда выдаваться объект (dict), редиректы неприемлимы. Если на сервере произошли ошибки, этот объект должен содержать свойство '_errors' - текстовое описание ошибки или массив текстовых описаний ошибок.
 * 2.
    retval = {
        '_request_id': request.get('_request_id'), <-- необходимо пробрасывать на выход входной параметр '_request_id'
        'filters': filters,
        'data': data
    }
    return retval
 */
const Ajax__MAX_ID = 32000;
class Ajax{
    constructor(){
        this._id = 1; // id запроса на сервер
        this._pending = [];
        this._cache = {};
    }
    request(p_url, p_paramObject, p_okFunc, p_errorFunc){
        //App.backend.callMethod(p_url, p_paramObject).then(p_okFunc).catch(p_errorFunc);
        this._id = ++this._id;// % Ajax__MAX_ID;
        if (this._id > Ajax__MAX_ID){
            // ...
        }
        p_paramObject._request_id = this._id;
        (function(self, p_okFunc, p_errorFunc, p_request_id){
            var common = function(p_func, p_paramObj){// p_func и p_paramObj - функция и параметр обратного вызова
                var i, a = self._pending.indexOf(p_request_id);
                if (a < 0)
                    return; // запрос был снят
                self._pending.splice(a, 1);
                self._cache[p_request_id] = {func: p_func, param: p_paramObj};
                // если все id в _pending больше p_request_id, то проходим циклом по _cache и если request_id <= p_request_id, то вызываем соответствующие фунции и убираем эти свйоства из _cache
                a = true;
                for (i = 0 ; i < self._pending.length ; ++i){
                    if (self._pending[i] > p_request_id)
                        a = false;
                }
                if (a){
                    a = [];
                    for (i in self._cache){
                        if (i <= p_request_id){
                            self._cache[i].func(self._cache[i].param);
                            a.push(i);
                        }
                    }
                    while (a.length){
                        i = a.pop();
                        delete self._cache[i];
                    }
                }
                //else
                //    console.log('Ещё не все пришили. Ожидаю.');
            };
            var fOk = function(p_data){
                delete p_data['_request_id'];
                if (p_data._errors)
                    common(p_errorFunc, {error: p_data._errors});
                else
                    common(p_okFunc, p_data);
            };
            var fError = function(p_error){
                common(p_errorFunc, {error: p_error});
            };
            if (p_url === '_fake'){
                fOk(p_paramObject);
            }
            else{
                self._pending.push(p_request_id);
                App.backend.callMethod(p_url, p_paramObject).then(fOk).catch(fError);
            }
        })(this, p_okFunc, p_errorFunc, this._id);
    }
    break(){
        var i, retVal = this._pending.length;
        this._pending = [];
        for (i in this._cache){
            delete this._cache[i];
            //this._pending.push(i);
        }
        console.log('--- отменено запросов: ', retVal,  ' ---');
        return retVal;
    }
}

    return Ajax;
});
