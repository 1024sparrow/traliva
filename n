src/ - исходники traliva
src/build_scripts/targets/ - директория с правилами сборки под разные платформы (они хранятся в отдельных репозиториях)
src/project_compiled/ - директория с бессерверным вариантом сборки (для разработчика)
compiled/ - результат компиляции исходников. Это ещё не рузультат разработки.
targets/ - проекты под разные платформы. Это копия из compiled, модифицируемая программистом.

Сборка:
compile src/pro - сборка под платформы. Бессерверный вариант не собирается.
compile src/project/project.pro - сборка бессерверной части (для разработчика). Под платформы код не формируется.

===============================================

<!DOCTYPE html>
<!--[if IE]><![endif]-->
<!--[if IE 8 ]><html dir="ltr" lang="ru" class="ie8"><![endif]-->
<!--[if IE 9 ]><html dir="ltr" lang="ru" class="ie9"><![endif]-->
<!--[if (gt IE 9)|!(IE)]><!-->
<html dir="ltr" lang="ru">
<!--<![endif]-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, user-scalable=0">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<title>Уличный стиль и минимализм | Одежда из натуральных тканей | Гнездо Маркет</title>
<base href="https://gnezdo-market.ru/" />
<meta name="description" content="Одежда с дизайнерскими принтами – лимитированные коллекции, экологичные материалы, минимализм. 
Без котиков и сисек, но в центре внимания!" />
<meta name="keywords" content= "дизайнерская одежда, футболки, свитшоты, платья, мандалы, принты, минимализм, уличный стиль, экологичные материалы " />
<meta property="og:title" content="Уличный стиль и минимализм | Одежда из натуральных тканей | Гнездо Маркет" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://gnezdo-market.ru/" /><meta property="og:image" content="https://gnezdo-market.ru/image/catalog/gnezdo/og_image.png" />
<meta property="og:site_name" content="Гнездо Маркет" />

----------------------------------------------

    Traliva.debug = true;
    var Traliva__log__re = /\(([^\)]*)\)/gi;
    Traliva.log = function(){
        var $0, error, $1;
        if (Traliva.debug){
            error = new Error();
            $0 = error.stack.match(Traliva__log__re);
            $1 = Array.prototype.slice.call(arguments);
            $0 = $0[1];
            $1.unshift($0.substr(1, $0.length - 2) + ':\n');
            console.log.apply(console, $1);
        }
    };

    Traliva.log('update arrows data:', s.data);//

----------------------------------------------


defineContext([], function(App){

/*
 * Обёртка над Traliva.ajax
 * Обеспечивает получение ответов от сервера в том же порядке, как посылались запросы.
 * Запросы выполнять методом  request().
 * Метод break() "отменяет" все ранее сделанные запросы (ответы игнорируются) и возвращает число "отменённых" запросов.
 * Если в качестве URL передать '_fake', то объект, переданный на вход, будет выдан на выход без каких-либо запросов на сервер.
 *
 * Требования к серверному коду (python):
 * 1. На выход должен всегда выдаваться объект (dict), редиректы неприемлимы. Если на сервере произошли ошибки, этот объект должен содержать свойство '_errors' - текстовое описание ошибки или массив текстовых описаний ошибок.
 * 2.
    retval = {
        '_request_id': request.get('_request_id'), <-- необходимо пробрасывать на выход входной параметр '_request_id'
        'filters': filters,
        'data': data
    }
    return retval
 */
const Ajax__MAX_ID = 32000;
class Ajax{
    constructor(){
        this._id = 1; // id запроса на сервер
        this._pending = [];
        this._cache = {};
    }
    request(p_url, p_paramObject, p_okFunc, p_errorFunc){
        //App.backend.callMethod(p_url, p_paramObject).then(p_okFunc).catch(p_errorFunc);
        this._id = ++this._id;// % Ajax__MAX_ID;
        if (this._id > Ajax__MAX_ID){
            // ...
        }
        p_paramObject._request_id = this._id;
        (function(self, p_okFunc, p_errorFunc, p_request_id){
            var common = function(p_func, p_paramObj){// p_func и p_paramObj - функция и параметр обратного вызова
                var i, a = self._pending.indexOf(p_request_id);
                if (a < 0)
                    return; // запрос был снят
                self._pending.splice(a, 1);
                self._cache[p_request_id] = {func: p_func, param: p_paramObj};
                // если все id в _pending больше p_request_id, то проходим циклом по _cache и если request_id <= p_request_id, то вызываем соответствующие фунции и убираем эти свйоства из _cache
                a = true;
                for (i = 0 ; i < self._pending.length ; ++i){
                    if (self._pending[i] > p_request_id)
                        a = false;
                }
                if (a){
                    a = [];
                    for (i in self._cache){
                        if (i <= p_request_id){
                            self._cache[i].func(self._cache[i].param);
                            a.push(i);
                        }
                    }
                    while (a.length){
                        i = a.pop();
                        delete self._cache[i];
                    }
                }
                //else
                //    console.log('Ещё не все пришили. Ожидаю.');
            };
            var fOk = function(p_data){
                delete p_data['_request_id'];
                if (p_data._errors)
                    common(p_errorFunc, {error: p_data._errors});
                else
                    common(p_okFunc, p_data);
            };
            var fError = function(p_error){
                common(p_errorFunc, {error: p_error});
            };
            if (p_url === '_fake'){
                fOk(p_paramObject);
            }
            else{
                self._pending.push(p_request_id);
                App.backend.callMethod(p_url, p_paramObject).then(fOk).catch(fError);
            }
        })(this, p_okFunc, p_errorFunc, this._id);
    }
    break(){
        var i, retVal = this._pending.length;
        this._pending = [];
        for (i in this._cache){
            delete this._cache[i];
            //this._pending.push(i);
        }
        console.log('--- отменено запросов: ', retVal,  ' ---');
        return retVal;
    }
}

    return Ajax;
});
